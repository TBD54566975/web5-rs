namespace web5 {
  [Throws=BearerDidError, Async]
  BearerDid bearer_did_from_key_manager([ByRef] string did_uri, KeyManager key_manager);

  [Throws=MethodError]
  BearerDid create_did_jwk(LocalKeyManager key_manager, DidJwkCreateOptions options);

  [Throws=JwtError]
  string sign_jwt([ByRef] BearerDid bearer_did, [ByRef] KeySelector key_selector, [ByRef] string encoded_header, [ByRef] string encoded_payload);
  [Throws=JwtError, Async]
  void verify_jwt([ByRef] string jwt);

  [Throws=CredentialError, Async]
  VerifiableCredential verify_vcjwt([ByRef] string jwt);

  PrivateKey private_key_from_jwk(Jwk jwk);

  KeyManager key_manager_from_local_key_manager(LocalKeyManager local_key_manager);
};

[Error]
enum KeyError {
  "KeyGenerationFailed",
  "SerializationFailed",
  "CurveNotFound",
  "AlgorithmNotFound",
  "JwkError",
  "CryptoError",
};

[Trait]
interface Key {
  [Throws=KeyError]
  string alias();
  [Throws=KeyError]
  Jwk jwk();
};

[Trait]
interface PublicKey {
  [Throws=KeyError]
  void verify([ByRef] sequence<u8> payload, [ByRef] sequence<u8> signature);

  [Throws=KeyError]
  string alias();
  [Throws=KeyError]
  Jwk jwk();
};

[Trait]
interface PrivateKey {
  [Throws=KeyError]
  PublicKey to_public();
  [Throws=KeyError]
  bytes sign([ByRef] sequence<u8> payload);

  [Throws=KeyError]
  string alias();
  [Throws=KeyError]
  Jwk jwk();
};

[Error]
enum JwkError {
  "ThumbprintFailed",
};

interface Jwk {
  constructor(string alg, string kty, string crv, string? d, string x, string? y);

  string get_alg();
  string get_kty();
  string get_crv();
  string? get_d();
  string get_x();
  string? get_y();  

  [Throws=JwkError]
  string compute_thumbprint();

  [Throws=KeyError]
  string alias();
  [Throws=KeyError]
  Jwk jwk();

  [Throws=KeyError]
  void verify([ByRef] sequence<u8> payload, [ByRef] sequence<u8> signature);

  [Throws=KeyError]
  PublicKey to_public();
  [Throws=KeyError]
  bytes sign([ByRef] sequence<u8> payload);
};

enum Curve {
  "Secp256k1",
  "Ed25519",
};

[Error]
enum KeyManagerError {
  "KeyGenerationFailed",
  "SigningKeyNotFound",
  "KeyError",
  "KeyStoreError",
};

[Trait]
interface KeyManager {
  [Throws=KeyManagerError]
  string generate_private_key(Curve curve, string? key_alias);
  [Throws=KeyManagerError]
  PublicKey get_public_key([ByRef] string key_alias);
  [Throws=KeyManagerError]
  bytes sign([ByRef] string key_alias, [ByRef] sequence<u8> payload);
  [Throws=KeyManagerError]
  sequence<PrivateKey> export_private_keys();
  [Throws=KeyManagerError]
  void import_private_keys(sequence<PrivateKey> private_keys);
};

interface LocalKeyManager {
  constructor(KeyStore key_store);
  [Name=new_in_memory]
  constructor();

  [Throws=KeyManagerError]
  string generate_private_key(Curve curve, string? key_alias);
  [Throws=KeyManagerError]
  PublicKey get_public_key([ByRef] string key_alias);
  [Throws=KeyManagerError]
  bytes sign([ByRef] string key_alias, [ByRef] sequence<u8> payload);
  [Throws=KeyManagerError]
  sequence<PrivateKey> export_private_keys();
  [Throws=KeyManagerError]
  void import_private_keys(sequence<PrivateKey> private_keys);
};

[Error]
enum KeyStoreError {
  "InternalKeyStoreError",
  "KeyError",
  "KeyNotFound",
  "CryptoError",
  "JwkError",
  "UnsupportedOperation",
};

[Trait]
interface KeyStore {
  [Throws=KeyStoreError]
  string generate_new(Curve curve, string? key_alias);
  [Throws=KeyStoreError]
  sequence<string> get_all_aliases();
  [Throws=KeyStoreError]
  bytes sign([ByRef] string key_alias, [ByRef] sequence<u8> payload);
  [Throws=KeyStoreError]
  PublicKey get_public_key([ByRef] string key_alias);
  [Throws=KeyStoreError]
  sequence<PrivateKey> export_private_keys();
  [Throws=KeyStoreError]
  void import_private_keys(sequence<PrivateKey> private_keys);
};

interface InMemoryKeyStore {
  constructor();

  [Throws=KeyStoreError]
  string generate_new(Curve curve, string? key_alias);
  [Throws=KeyStoreError]
  sequence<string> get_all_aliases();
  [Throws=KeyStoreError]
  bytes sign([ByRef] string key_alias, [ByRef] sequence<u8> payload);
  [Throws=KeyStoreError]
  PublicKey get_public_key([ByRef] string key_alias);
  [Throws=KeyStoreError]
  sequence<PrivateKey> export_private_keys();
  [Throws=KeyStoreError]
  void import_private_keys(sequence<PrivateKey> private_keys);
};

[Error]
enum BearerDidError {
  "VerificationMethodNotFound",
  "KeyManagerError",
  "KeyError",
  "DocumentError",
  "ResolutionError",
  "IdentifierError",
};

enum VerificationMethodType {
  "VerificationMethod",
  "AssertionMethod",
  "Authentication",
  "CapabilityDelegation",
  "CapabilityInvocation",
};

[Enum]
interface KeySelector {
  KeyId(string key_id);
  MethodType(VerificationMethodType verification_method_type);
};

interface BearerDid {
  [Throws=BearerDidError]
  bytes sign([ByRef] KeySelector key_selector, [ByRef] sequence<u8> payload);
};

[Error]
enum JwtError {
  "JwsError",
  "SerializationError",
  "DeserializationError",
};

interface Claims {
  constructor(string? issuer, string? subject, string? audience, i64? expiration, i64? not_before, i64? issued_at, string? jti);
  [Throws=JwtError]
  string encode();
  [Throws=JwtError]
  string sign([ByRef] BearerDid bearer_did, [ByRef] KeySelector key_selector);
};

dictionary CredentialSubject {
  string id;
  record<string, string>? params;
};

[Error]
enum CredentialError {
  "JwtError",
  "JwsError",
};

interface VerifiableCredential {
  constructor(sequence<string> context, string id, sequence<string> type, string issuer, i64 issuance_date, i64? expiration_date, CredentialSubject credential_subject);
  [Throws=CredentialError]
  string sign([ByRef] BearerDid bearer_did, [ByRef] KeySelector key_selector);
};

dictionary DidJwkCreateOptions {
  Curve curve;
};

[Error]
enum MethodError {
  "KeyManagerError",
  "KeyError",
  "DidCreationFailure",
};